{
	"objects" : [
		"acf",
		"acf2AR",
		"add.scope",
		"add1",
		"addmargins",
		"aggregate",
		"aggregate.data.frame",
		"aggregate.ts",
		"AIC",
		"alias",
		"anova",
		"ansari.test",
		"aov",
		"approx",
		"approxfun",
		"ar",
		"ar.burg",
		"ar.mle",
		"ar.ols",
		"ar.yw",
		"arima",
		"arima.sim",
		"arima0",
		"arima0.diag",
		"ARMAacf",
		"ARMAtoMA",
		"as.dendrogram",
		"as.dist",
		"as.formula",
		"as.hclust",
		"as.stepfun",
		"as.ts",
		"asOneSidedFormula",
		"ave",
		"bandwidth.kernel",
		"bartlett.test",
		"BIC",
		"binom.test",
		"binomial",
		"biplot",
		"Box.test",
		"bw.bcv",
		"bw.nrd",
		"bw.nrd0",
		"bw.SJ",
		"bw.ucv",
		"cancor",
		"case.names",
		"ccf",
		"chisq.test",
		"cmdscale",
		"coef",
		"coefficients",
		"complete.cases",
		"confint",
		"confint.default",
		"confint.lm",
		"constrOptim",
		"contr.helmert",
		"contr.poly",
		"contr.SAS",
		"contr.sum",
		"contr.treatment",
		"contrasts",
		"convolve",
		"cooks.distance",
		"cophenetic",
		"cor",
		"cor.test",
		"cov",
		"cov.wt",
		"cov2cor",
		"covratio",
		"cpgram",
		"cutree",
		"cycle",
		"dbeta",
		"dbinom",
		"dcauchy",
		"dchisq",
		"decompose",
		"delete.response",
		"deltat",
		"dendrapply",
		"density",
		"density.default",
		"deriv",
		"deriv3",
		"deviance",
		"dexp",
		"df",
		"df.kernel",
		"df.residual",
		"dfbeta",
		"dfbetas",
		"dffits",
		"dgamma",
		"dgeom",
		"dhyper",
		"diffinv",
		"dist",
		"dlnorm",
		"dlogis",
		"dmultinom",
		"dnbinom",
		"dnorm",
		"dpois",
		"drop.scope",
		"drop.terms",
		"drop1",
		"dsignrank",
		"dt",
		"dummy.coef",
		"dummy.coef.lm",
		"dunif",
		"dweibull",
		"dwilcox",
		"ecdf",
		"eff.aovlist",
		"effects",
		"embed",
		"end",
		"estVar",
		"expand.model.frame",
		"extractAIC",
		"factanal",
		"factor.scope",
		"family",
		"fft",
		"filter",
		"fisher.test",
		"fitted",
		"fitted.values",
		"fivenum",
		"fligner.test",
		"formula",
		"frequency",
		"friedman.test",
		"ftable",
		"Gamma",
		"gaussian",
		"get_all_vars",
		"getCall",
		"getInitial",
		"glm",
		"glm.control",
		"glm.fit",
		"hasTsp",
		"hat",
		"hatvalues",
		"hclust",
		"heatmap",
		"HoltWinters",
		"influence",
		"influence.measures",
		"integrate",
		"interaction.plot",
		"inverse.gaussian",
		"IQR",
		"is.empty.model",
		"is.leaf",
		"is.mts",
		"is.stepfun",
		"is.ts",
		"is.tskernel",
		"isoreg",
		"KalmanForecast",
		"KalmanLike",
		"KalmanRun",
		"KalmanSmooth",
		"kernapply",
		"kernel",
		"kmeans",
		"knots",
		"kruskal.test",
		"ks.test",
		"ksmooth",
		"lag",
		"lag.plot",
		"line",
		"lm",
		"lm.fit",
		"lm.influence",
		"lm.wfit",
		"loadings",
		"loess",
		"loess.control",
		"loess.smooth",
		"logLik",
		"loglin",
		"lowess",
		"ls.diag",
		"ls.print",
		"lsfit",
		"mad",
		"mahalanobis",
		"make.link",
		"makeARIMA",
		"makepredictcall",
		"manova",
		"mantelhaen.test",
		"mauchly.test",
		"mcnemar.test",
		"median",
		"median.default",
		"medpolish",
		"model.extract",
		"model.frame",
		"model.frame.default",
		"model.matrix",
		"model.matrix.default",
		"model.matrix.lm",
		"model.offset",
		"model.response",
		"model.tables",
		"model.weights",
		"monthplot",
		"mood.test",
		"mvfft",
		"na.action",
		"na.contiguous",
		"na.exclude",
		"na.fail",
		"na.omit",
		"na.pass",
		"napredict",
		"naprint",
		"naresid",
		"nextn",
		"nlm",
		"nlminb",
		"nls",
		"nls.control",
		"NLSstAsymptotic",
		"NLSstClosestX",
		"NLSstLfAsymptote",
		"NLSstRtAsymptote",
		"nobs",
		"numericDeriv",
		"offset",
		"oneway.test",
		"optim",
		"optimHess",
		"optimise",
		"optimize",
		"order.dendrogram",
		"p.adjust",
		"p.adjust.methods",
		"pacf",
		"pairwise.prop.test",
		"pairwise.t.test",
		"pairwise.table",
		"pairwise.wilcox.test",
		"pbeta",
		"pbinom",
		"pbirthday",
		"pcauchy",
		"pchisq",
		"pexp",
		"pf",
		"pgamma",
		"pgeom",
		"phyper",
		"plclust",
		"plnorm",
		"plogis",
		"plot.ecdf",
		"plot.spec.coherency",
		"plot.spec.phase",
		"plot.stepfun",
		"plot.ts",
		"pnbinom",
		"pnorm",
		"poisson",
		"poisson.test",
		"poly",
		"polym",
		"power",
		"power.anova.test",
		"power.prop.test",
		"power.t.test",
		"PP.test",
		"ppoints",
		"ppois",
		"ppr",
		"prcomp",
		"predict",
		"predict.glm",
		"predict.lm",
		"preplot",
		"princomp",
		"printCoefmat",
		"profile",
		"proj",
		"promax",
		"prop.test",
		"prop.trend.test",
		"psignrank",
		"pt",
		"ptukey",
		"punif",
		"pweibull",
		"pwilcox",
		"qbeta",
		"qbinom",
		"qbirthday",
		"qcauchy",
		"qchisq",
		"qexp",
		"qf",
		"qgamma",
		"qgeom",
		"qhyper",
		"qlnorm",
		"qlogis",
		"qnbinom",
		"qnorm",
		"qpois",
		"qqline",
		"qqnorm",
		"qqplot",
		"qsignrank",
		"qt",
		"qtukey",
		"quade.test",
		"quantile",
		"quasi",
		"quasibinomial",
		"quasipoisson",
		"qunif",
		"qweibull",
		"qwilcox",
		"r2dtable",
		"rbeta",
		"rbinom",
		"rcauchy",
		"rchisq",
		"read.ftable",
		"rect.hclust",
		"reformulate",
		"relevel",
		"reorder",
		"replications",
		"reshape",
		"resid",
		"residuals",
		"residuals.glm",
		"residuals.lm",
		"rexp",
		"rf",
		"rgamma",
		"rgeom",
		"rhyper",
		"rlnorm",
		"rlogis",
		"rmultinom",
		"rnbinom",
		"rnorm",
		"rpois",
		"rsignrank",
		"rstandard",
		"rstudent",
		"rt",
		"runif",
		"runmed",
		"rweibull",
		"rwilcox",
		"rWishart",
		"scatter.smooth",
		"screeplot",
		"sd",
		"se.contrast",
		"selfStart",
		"setNames",
		"shapiro.test",
		"sigma",
		"simulate",
		"smooth",
		"smooth.spline",
		"smoothEnds",
		"sortedXyData",
		"spec.ar",
		"spec.pgram",
		"spec.taper",
		"spectrum",
		"spline",
		"splinefun",
		"splinefunH",
		"SSasymp",
		"SSasympOff",
		"SSasympOrig",
		"SSbiexp",
		"SSD",
		"SSfol",
		"SSfpl",
		"SSgompertz",
		"SSlogis",
		"SSmicmen",
		"SSweibull",
		"start",
		"stat.anova",
		"step",
		"stepfun",
		"stl",
		"StructTS",
		"summary.aov",
		"summary.glm",
		"summary.lm",
		"summary.manova",
		"summary.stepfun",
		"supsmu",
		"symnum",
		"t.test",
		"termplot",
		"terms",
		"terms.formula",
		"time",
		"toeplitz",
		"ts",
		"ts.intersect",
		"ts.plot",
		"ts.union",
		"tsdiag",
		"tsp",
		"tsSmooth",
		"TukeyHSD",
		"uniroot",
		"update",
		"update.default",
		"update.formula",
		"var",
		"var.test",
		"variable.names",
		"varimax",
		"vcov",
		"weighted.mean",
		"weighted.residuals",
		"weights",
		"wilcox.test",
		"window",
		"write.ftable",
		"xtabs"
	],
	"methods" : {
		"acf" : "acf(x, lag.max = NULL, type = c(\"correlation\", \"covariance\", \"partial\"), plot = TRUE, na.action = na.fail, demean = TRUE, ...) ",
		"acf2AR" : "acf2AR(acf) ",
		"add.scope" : "add.scope(terms1, terms2) ",
		"add1" : "add1(object, scope, ...) ",
		"addmargins" : "addmargins(A, margin = seq_along(dim(A)), FUN = sum, quiet = FALSE) ",
		"aggregate" : "aggregate(x, ...) ",
		"aggregate.data.frame" : "aggregate.data.frame(x, by, FUN, ..., simplify = TRUE, drop = TRUE) ",
		"aggregate.ts" : "aggregate.ts(x, nfrequency = 1, FUN = sum, ndeltat = 1, ts.eps = getOption(\"ts.eps\"), ...) ",
		"AIC" : "AIC(object, ..., k = 2) ",
		"alias" : "alias(object, ...) ",
		"anova" : "anova(object, ...) ",
		"ansari.test" : "ansari.test(x, ...) ",
		"aov" : "aov(formula, data = NULL, projections = FALSE, qr = TRUE, contrasts = NULL, ...) ",
		"approx" : "approx(x, y = NULL, xout, method = \"linear\", n = 50, yleft, yright, rule = 1, f = 0, ties = mean) ",
		"approxfun" : "approxfun(x, y = NULL, method = \"linear\", yleft, yright, rule = 1, f = 0, ties = mean) ",
		"ar" : "ar(x, aic = TRUE, order.max = NULL, method = c(\"yule-walker\", \"burg\", \"ols\", \"mle\", \"yw\"), na.action = na.fail, series = deparse(substitute(x)), ...) ",
		"ar.burg" : "ar.burg(x, ...) ",
		"ar.mle" : "ar.mle(x, aic = TRUE, order.max = NULL, na.action = na.fail, demean = TRUE, series = NULL, ...) ",
		"ar.ols" : "ar.ols(x, aic = TRUE, order.max = NULL, na.action = na.fail, demean = TRUE, intercept = demean, series = NULL, ...) ",
		"ar.yw" : "ar.yw(x, ...) ",
		"arima" : "arima(x, order = c(0L, 0L, 0L), seasonal = list(order = c(0L, 0L, 0L), period = NA), xreg = NULL, include.mean = TRUE, transform.pars = TRUE, fixed = NULL, init = NULL, method = c(\"CSS-ML\",     \"ML\", \"CSS\"), n.cond, SSinit = c(\"Gardner1980\", \"Rossignol2011\"), optim.method = \"BFGS\", optim.control = list(), kappa = 1e+06) ",
		"arima.sim" : "arima.sim(model, n, rand.gen = rnorm, innov = rand.gen(n, ...), n.start = NA, start.innov = rand.gen(n.start, ...), ...) ",
		"arima0" : "arima0(x, order = c(0, 0, 0), seasonal = list(order = c(0, 0, 0), period = NA), xreg = NULL, include.mean = TRUE, delta = 0.01, transform.pars = TRUE, fixed = NULL, init = NULL, method = c(\"ML\",     \"CSS\"), n.cond, optim.control = list()) ",
		"arima0.diag" : "arima0.diag(...) ",
		"ARMAacf" : "ARMAacf(ar = numeric(), ma = numeric(), lag.max = r, pacf = FALSE) ",
		"ARMAtoMA" : "ARMAtoMA(ar = numeric(), ma = numeric(), lag.max) ",
		"as.dendrogram" : "as.dendrogram(object, ...) ",
		"as.dist" : "as.dist(m, diag = FALSE, upper = FALSE) ",
		"as.formula" : "as.formula(object, env = parent.frame()) ",
		"as.hclust" : "as.hclust(x, ...) ",
		"as.stepfun" : "as.stepfun(x, ...) ",
		"as.ts" : "as.ts(x, ...) ",
		"asOneSidedFormula" : "asOneSidedFormula(object) ",
		"ave" : "ave(x, ..., FUN = mean) ",
		"bandwidth.kernel" : "bandwidth.kernel(k) ",
		"bartlett.test" : "bartlett.test(x, ...) ",
		"BIC" : "BIC(object, ...) ",
		"binom.test" : "binom.test(x, n, p = 0.5, alternative = c(\"two.sided\", \"less\", \"greater\"), conf.level = 0.95) ",
		"binomial" : "binomial(link = \"logit\") ",
		"biplot" : "biplot(x, ...) ",
		"Box.test" : "Box.test(x, lag = 1, type = c(\"Box-Pierce\", \"Ljung-Box\"), fitdf = 0) ",
		"bw.bcv" : "bw.bcv(x, nb = 1000L, lower = 0.1 * hmax, upper = hmax, tol = 0.1 * lower) ",
		"bw.nrd" : "bw.nrd(x) ",
		"bw.nrd0" : "bw.nrd0(x) ",
		"bw.SJ" : "bw.SJ(x, nb = 1000L, lower = 0.1 * hmax, upper = hmax, method = c(\"ste\", \"dpi\"), tol = 0.1 * lower) ",
		"bw.ucv" : "bw.ucv(x, nb = 1000L, lower = 0.1 * hmax, upper = hmax, tol = 0.1 * lower) ",
		"cancor" : "cancor(x, y, xcenter = TRUE, ycenter = TRUE) ",
		"case.names" : "case.names(object, ...) ",
		"ccf" : "ccf(x, y, lag.max = NULL, type = c(\"correlation\", \"covariance\"), plot = TRUE, na.action = na.fail, ...) ",
		"chisq.test" : "chisq.test(x, y = NULL, correct = TRUE, p = rep(1/length(x), length(x)), rescale.p = FALSE, simulate.p.value = FALSE, B = 2000) ",
		"cmdscale" : "cmdscale(d, k = 2, eig = FALSE, add = FALSE, x.ret = FALSE, list. = eig || add || x.ret) ",
		"coef" : "coef(object, ...) ",
		"coefficients" : "coefficients(object, ...) ",
		"complete.cases" : "complete.cases(...) ",
		"confint" : "confint(object, parm, level = 0.95, ...) ",
		"confint.default" : "confint.default(object, parm, level = 0.95, ...) ",
		"confint.lm" : "confint.lm(object, parm, level = 0.95, ...) ",
		"constrOptim" : "constrOptim(theta, f, grad, ui, ci, mu = 1e-04, control = list(), method = if (is.null(grad)) \"Nelder-Mead\" else \"BFGS\", outer.iterations = 100, outer.eps = 1e-05, ..., hessian = FALSE) ",
		"contr.helmert" : "contr.helmert(n, contrasts = TRUE, sparse = FALSE) ",
		"contr.poly" : "contr.poly(n, scores = 1:n, contrasts = TRUE, sparse = FALSE) ",
		"contr.SAS" : "contr.SAS(n, contrasts = TRUE, sparse = FALSE) ",
		"contr.sum" : "contr.sum(n, contrasts = TRUE, sparse = FALSE) ",
		"contr.treatment" : "contr.treatment(n, base = 1, contrasts = TRUE, sparse = FALSE) ",
		"contrasts" : "contrasts(x, contrasts = TRUE, sparse = FALSE) ",
		"convolve" : "convolve(x, y, conj = TRUE, type = c(\"circular\", \"open\", \"filter\")) ",
		"cooks.distance" : "cooks.distance(model, ...) ",
		"cophenetic" : "cophenetic(x) ",
		"cor" : "cor(x, y = NULL, use = \"everything\", method = c(\"pearson\", \"kendall\", \"spearman\")) ",
		"cor.test" : "cor.test(x, ...) ",
		"cov" : "cov(x, y = NULL, use = \"everything\", method = c(\"pearson\", \"kendall\", \"spearman\")) ",
		"cov.wt" : "cov.wt(x, wt = rep(1/nrow(x), nrow(x)), cor = FALSE, center = TRUE, method = c(\"unbiased\", \"ML\")) ",
		"cov2cor" : "cov2cor(V) ",
		"covratio" : "covratio(model, infl = lm.influence(model, do.coef = FALSE), res = weighted.residuals(model)) ",
		"cpgram" : "cpgram(ts, taper = 0.1, main = paste(\"Series: \", deparse(substitute(ts))), ci.col = \"blue\") ",
		"cutree" : "cutree(tree, k = NULL, h = NULL) ",
		"cycle" : "cycle(x, ...) ",
		"dbeta" : "dbeta(x, shape1, shape2, ncp = 0, log = FALSE) ",
		"dbinom" : "dbinom(x, size, prob, log = FALSE) ",
		"dcauchy" : "dcauchy(x, location = 0, scale = 1, log = FALSE) ",
		"dchisq" : "dchisq(x, df, ncp = 0, log = FALSE) ",
		"decompose" : "decompose(x, type = c(\"additive\", \"multiplicative\"), filter = NULL) ",
		"delete.response" : "delete.response(termobj) ",
		"deltat" : "deltat(x, ...) ",
		"dendrapply" : "dendrapply(X, FUN, ...) ",
		"density" : "density(x, ...) ",
		"density.default" : "density.default(x, bw = \"nrd0\", adjust = 1, kernel = c(\"gaussian\", \"epanechnikov\", \"rectangular\", \"triangular\", \"biweight\", \"cosine\", \"optcosine\"), weights = NULL, window = kernel, width, give.Rkern = FALSE, n = 512, from, to, cut = 3, na.rm = FALSE, ...) ",
		"deriv" : "deriv(expr, ...) ",
		"deriv3" : "deriv3(expr, ...) ",
		"deviance" : "deviance(object, ...) ",
		"dexp" : "dexp(x, rate = 1, log = FALSE) ",
		"df" : "df(x, df1, df2, ncp, log = FALSE) ",
		"df.kernel" : "df.kernel(k) ",
		"df.residual" : "df.residual(object, ...) ",
		"dfbeta" : "dfbeta(model, ...) ",
		"dfbetas" : "dfbetas(model, ...) ",
		"dffits" : "dffits(model, infl = lm.influence(model, do.coef = FALSE), res = weighted.residuals(model)) ",
		"dgamma" : "dgamma(x, shape, rate = 1, scale = 1/rate, log = FALSE) ",
		"dgeom" : "dgeom(x, prob, log = FALSE) ",
		"dhyper" : "dhyper(x, m, n, k, log = FALSE) ",
		"diffinv" : "diffinv(x, ...) ",
		"dist" : "dist(x, method = \"euclidean\", diag = FALSE, upper = FALSE, p = 2) ",
		"dlnorm" : "dlnorm(x, meanlog = 0, sdlog = 1, log = FALSE) ",
		"dlogis" : "dlogis(x, location = 0, scale = 1, log = FALSE) ",
		"dmultinom" : "dmultinom(x, size = NULL, prob, log = FALSE) ",
		"dnbinom" : "dnbinom(x, size, prob, mu, log = FALSE) ",
		"dnorm" : "dnorm(x, mean = 0, sd = 1, log = FALSE) ",
		"dpois" : "dpois(x, lambda, log = FALSE) ",
		"drop.scope" : "drop.scope(terms1, terms2) ",
		"drop.terms" : "drop.terms(termobj, dropx = NULL, keep.response = FALSE) ",
		"drop1" : "drop1(object, scope, ...) ",
		"dsignrank" : "dsignrank(x, n, log = FALSE) ",
		"dt" : "dt(x, df, ncp, log = FALSE) ",
		"dummy.coef" : "dummy.coef(object, ...) ",
		"dummy.coef.lm" : "dummy.coef.lm(object, use.na = FALSE, ...) ",
		"dunif" : "dunif(x, min = 0, max = 1, log = FALSE) ",
		"dweibull" : "dweibull(x, shape, scale = 1, log = FALSE) ",
		"dwilcox" : "dwilcox(x, m, n, log = FALSE) ",
		"ecdf" : "ecdf(x) ",
		"eff.aovlist" : "eff.aovlist(aovlist) ",
		"effects" : "effects(object, ...) ",
		"embed" : "embed(x, dimension = 1) ",
		"end" : "end(x, ...) ",
		"estVar" : "estVar(object, ...) ",
		"expand.model.frame" : "expand.model.frame(model, extras, envir = environment(formula(model)), na.expand = FALSE) ",
		"extractAIC" : "extractAIC(fit, scale, k = 2, ...) ",
		"factanal" : "factanal(x, factors, data = NULL, covmat = NULL, n.obs = NA, subset, na.action, start = NULL, scores = c(\"none\", \"regression\",     \"Bartlett\"), rotation = \"varimax\", control = NULL, ...) ",
		"factor.scope" : "factor.scope(factor, scope) ",
		"family" : "family(object, ...) ",
		"fft" : "fft(z, inverse = FALSE) ",
		"filter" : "filter(x, filter, method = c(\"convolution\", \"recursive\"), sides = 2L, circular = FALSE, init = NULL) ",
		"fisher.test" : "fisher.test(x, y = NULL, workspace = 2e+05, hybrid = FALSE, control = list(), or = 1, alternative = \"two.sided\", conf.int = TRUE, conf.level = 0.95, simulate.p.value = FALSE, B = 2000) ",
		"fitted" : "fitted(object, ...) ",
		"fitted.values" : "fitted.values(object, ...) ",
		"fivenum" : "fivenum(x, na.rm = TRUE) ",
		"fligner.test" : "fligner.test(x, ...) ",
		"formula" : "formula(x, ...) ",
		"frequency" : "frequency(x, ...) ",
		"friedman.test" : "friedman.test(y, ...) ",
		"ftable" : "ftable(x, ...) ",
		"Gamma" : "Gamma(link = \"inverse\") ",
		"gaussian" : "gaussian(link = \"identity\") ",
		"get_all_vars" : "get_all_vars(formula, data = NULL, ...) ",
		"getCall" : "getCall(x, ...) ",
		"getInitial" : "getInitial(object, data, ...) ",
		"glm" : "glm(formula, family = gaussian, data, weights, subset, na.action, start = NULL, etastart, mustart, offset, control = list(...), model = TRUE, method = \"glm.fit\", x = FALSE, y = TRUE, contrasts = NULL, ...) ",
		"glm.control" : "glm.control(epsilon = 1e-08, maxit = 25, trace = FALSE) ",
		"glm.fit" : "glm.fit(x, y, weights = rep(1, nobs), start = NULL, etastart = NULL, mustart = NULL, offset = rep(0, nobs), family = gaussian(), control = list(), intercept = TRUE) ",
		"hasTsp" : "hasTsp(x) ",
		"hat" : "hat(x, intercept = TRUE) ",
		"hatvalues" : "hatvalues(model, ...) ",
		"hclust" : "hclust(d, method = \"complete\", members = NULL) ",
		"heatmap" : "heatmap(x, Rowv = NULL, Colv = if (symm) \"Rowv\" else NULL, distfun = dist, hclustfun = hclust, reorderfun = function(d,     w) reorder(d, w), add.expr, symm = FALSE, revC = identical(Colv,     \"Rowv\"), scale = c(\"row\", \"column\", \"none\"), na.rm = TRUE, margins = c(5, 5), ColSideColors, RowSideColors, cexRow = 0.2 +     1/log10(nr), cexCol = 0.2 + 1/log10(nc), labRow = NULL, labCol = NULL, main = NULL, xlab = NULL, ylab = NULL, keep.dendro = FALSE, verbose = getOption(\"verbose\"), ...) ",
		"HoltWinters" : "HoltWinters(x, alpha = NULL, beta = NULL, gamma = NULL, seasonal = c(\"additive\", \"multiplicative\"), start.periods = 2, l.start = NULL, b.start = NULL, s.start = NULL, optim.start = c(alpha = 0.3, beta = 0.1,     gamma = 0.1), optim.control = list()) ",
		"influence" : "influence(model, ...) ",
		"influence.measures" : "influence.measures(model) ",
		"integrate" : "integrate(f, lower, upper, ..., subdivisions = 100L, rel.tol = .Machine$double.eps^0.25, abs.tol = rel.tol, stop.on.error = TRUE, keep.xy = FALSE, aux = NULL) ",
		"interaction.plot" : "interaction.plot(x.factor, trace.factor, response, fun = mean, type = c(\"l\", \"p\", \"b\", \"o\", \"c\"), legend = TRUE, trace.label = deparse(substitute(trace.factor)), fixed = FALSE, xlab = deparse(substitute(x.factor)), ylab = ylabel, ylim = range(cells, na.rm = TRUE), lty = nc:1, col = 1, pch = c(1L:9,     0, letters), xpd = NULL, leg.bg = par(\"bg\"), leg.bty = \"n\", xtick = FALSE, xaxt = par(\"xaxt\"), axes = TRUE, ...) ",
		"inverse.gaussian" : "inverse.gaussian(link = \"1/mu^2\") ",
		"IQR" : "IQR(x, na.rm = FALSE, type = 7) ",
		"is.empty.model" : "is.empty.model(x) ",
		"is.leaf" : "is.leaf(object) ",
		"is.mts" : "is.mts(x) ",
		"is.stepfun" : "is.stepfun(x) ",
		"is.ts" : "is.ts(x) ",
		"is.tskernel" : "is.tskernel(k) ",
		"isoreg" : "isoreg(x, y = NULL) ",
		"KalmanForecast" : "KalmanForecast(n.ahead = 10L, mod, update = FALSE) ",
		"KalmanLike" : "KalmanLike(y, mod, nit = 0L, update = FALSE) ",
		"KalmanRun" : "KalmanRun(y, mod, nit = 0L, update = FALSE) ",
		"KalmanSmooth" : "KalmanSmooth(y, mod, nit = 0L) ",
		"kernapply" : "kernapply(x, ...) ",
		"kernel" : "kernel(coef, m = 2, r, name = \"unknown\") ",
		"kmeans" : "kmeans(x, centers, iter.max = 10L, nstart = 1L, algorithm = c(\"Hartigan-Wong\", \"Lloyd\", \"Forgy\", \"MacQueen\"), trace = FALSE) ",
		"knots" : "knots(Fn, ...) ",
		"kruskal.test" : "kruskal.test(x, ...) ",
		"ks.test" : "ks.test(x, y, ..., alternative = c(\"two.sided\", \"less\", \"greater\"), exact = NULL) ",
		"ksmooth" : "ksmooth(x, y, kernel = c(\"box\", \"normal\"), bandwidth = 0.5, range.x = range(x), n.points = max(100L, length(x)), x.points) ",
		"lag" : "lag(x, ...) ",
		"lag.plot" : "lag.plot(x, lags = 1, layout = NULL, set.lags = 1L:lags, main = NULL, asp = 1, diag = TRUE, diag.col = \"gray\", type = \"p\", oma = NULL, ask = NULL, do.lines = (n <= 150), labels = do.lines, ...) ",
		"line" : "line(x, y = NULL) ",
		"lm" : "lm(formula, data, subset, weights, na.action, method = \"qr\", model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE, contrasts = NULL, offset, ...) ",
		"lm.fit" : "lm.fit(x, y, offset = NULL, method = \"qr\", tol = 1e-07, singular.ok = TRUE, ...) ",
		"lm.influence" : "lm.influence(model, do.coef = TRUE) ",
		"lm.wfit" : "lm.wfit(x, y, w, offset = NULL, method = \"qr\", tol = 1e-07, singular.ok = TRUE, ...) ",
		"loadings" : "loadings(x, ...) ",
		"loess" : "loess(formula, data, weights, subset, na.action, model = FALSE, span = 0.75, enp.target, degree = 2L, parametric = FALSE, drop.square = FALSE, normalize = TRUE, family = c(\"gaussian\",     \"symmetric\"), method = c(\"loess\", \"model.frame\"), control = loess.control(...), ...) ",
		"loess.control" : "loess.control(surface = c(\"interpolate\", \"direct\"), statistics = c(\"approximate\", \"exact\", \"none\"), trace.hat = c(\"exact\", \"approximate\"), cell = 0.2, iterations = 4L, iterTrace = FALSE, ...) ",
		"loess.smooth" : "loess.smooth(x, y, span = 2/3, degree = 1, family = c(\"symmetric\", \"gaussian\"), evaluation = 50, ...) ",
		"logLik" : "logLik(object, ...) ",
		"loglin" : "loglin(table, margin, start = rep(1, length(table)), fit = FALSE, eps = 0.1, iter = 20L, param = FALSE, print = TRUE) ",
		"lowess" : "lowess(x, y = NULL, f = 2/3, iter = 3L, delta = 0.01 * diff(range(x))) ",
		"ls.diag" : "ls.diag(ls.out) ",
		"ls.print" : "ls.print(ls.out, digits = 4L, print.it = TRUE) ",
		"lsfit" : "lsfit(x, y, wt = NULL, intercept = TRUE, tolerance = 1e-07, yname = NULL) ",
		"mad" : "mad(x, center = median(x), constant = 1.4826, na.rm = FALSE, low = FALSE, high = FALSE) ",
		"mahalanobis" : "mahalanobis(x, center, cov, inverted = FALSE, ...) ",
		"make.link" : "make.link(link) ",
		"makeARIMA" : "makeARIMA(phi, theta, Delta, kappa = 1e+06, SSinit = c(\"Gardner1980\", \"Rossignol2011\"), tol = .Machine$double.eps) ",
		"makepredictcall" : "makepredictcall(var, call) ",
		"manova" : "manova(...) ",
		"mantelhaen.test" : "mantelhaen.test(x, y = NULL, z = NULL, alternative = c(\"two.sided\", \"less\", \"greater\"), correct = TRUE, exact = FALSE, conf.level = 0.95) ",
		"mauchly.test" : "mauchly.test(object, ...) ",
		"mcnemar.test" : "mcnemar.test(x, y = NULL, correct = TRUE) ",
		"median" : "median(x, na.rm = FALSE) ",
		"median.default" : "median.default(x, na.rm = FALSE) ",
		"medpolish" : "medpolish(x, eps = 0.01, maxiter = 10L, trace.iter = TRUE, na.rm = FALSE) ",
		"model.extract" : "model.extract(frame, component) ",
		"model.frame" : "model.frame(formula, ...) ",
		"model.frame.default" : "model.frame.default(formula, data = NULL, subset = NULL, na.action = na.fail, drop.unused.levels = FALSE, xlev = NULL, ...) ",
		"model.matrix" : "model.matrix(object, ...) ",
		"model.matrix.default" : "model.matrix.default(object, data = environment(object), contrasts.arg = NULL, xlev = NULL, ...) ",
		"model.matrix.lm" : "model.matrix.lm(object, ...) ",
		"model.offset" : "model.offset(x) ",
		"model.response" : "model.response(data, type = \"any\") ",
		"model.tables" : "model.tables(x, ...) ",
		"model.weights" : "model.weights(x) ",
		"monthplot" : "monthplot(x, ...) ",
		"mood.test" : "mood.test(x, ...) ",
		"mvfft" : "mvfft(z, inverse = FALSE) ",
		"na.action" : "na.action(object, ...) ",
		"na.contiguous" : "na.contiguous(object, ...) ",
		"na.exclude" : "na.exclude(object, ...) ",
		"na.fail" : "na.fail(object, ...) ",
		"na.omit" : "na.omit(object, ...) ",
		"na.pass" : "na.pass(object, ...) ",
		"napredict" : "napredict(omit, x, ...) ",
		"naprint" : "naprint(x, ...) ",
		"naresid" : "naresid(omit, x, ...) ",
		"nextn" : "nextn(n, factors = c(2, 3, 5)) ",
		"nlm" : "nlm(f, p, ..., hessian = FALSE, typsize = rep(1, length(p)), fscale = 1, print.level = 0, ndigit = 12, gradtol = 1e-06, stepmax = max(1000 * sqrt(sum((p/typsize)^2)), 1000), steptol = 1e-06, iterlim = 100, check.analyticals = TRUE) ",
		"nlminb" : "nlminb(start, objective, gradient = NULL, hessian = NULL, ..., scale = 1, control = list(), lower = -Inf, upper = Inf) ",
		"nls" : "nls(formula, data = parent.frame(), start, control = nls.control(), algorithm = c(\"default\", \"plinear\", \"port\"), trace = FALSE, subset, weights, na.action, model = FALSE, lower = -Inf, upper = Inf, ...) ",
		"nls.control" : "nls.control(maxiter = 50, tol = 1e-05, minFactor = 1/1024, printEval = FALSE, warnOnly = FALSE) ",
		"NLSstAsymptotic" : "NLSstAsymptotic(xy) ",
		"NLSstClosestX" : "NLSstClosestX(xy, yval) ",
		"NLSstLfAsymptote" : "NLSstLfAsymptote(xy) ",
		"NLSstRtAsymptote" : "NLSstRtAsymptote(xy) ",
		"nobs" : "nobs(object, ...) ",
		"numericDeriv" : "numericDeriv(expr, theta, rho = parent.frame(), dir = 1) ",
		"offset" : "offset(object) ",
		"oneway.test" : "oneway.test(formula, data, subset, na.action, var.equal = FALSE) ",
		"optim" : "optim(par, fn, gr = NULL, ..., method = c(\"Nelder-Mead\", \"BFGS\", \"CG\", \"L-BFGS-B\", \"SANN\", \"Brent\"), lower = -Inf, upper = Inf, control = list(), hessian = FALSE) ",
		"optimHess" : "optimHess(par, fn, gr = NULL, ..., control = list()) ",
		"optimise" : "optimise(f, interval, ..., lower = min(interval), upper = max(interval), maximum = FALSE, tol = .Machine$double.eps^0.25) ",
		"optimize" : "optimize(f, interval, ..., lower = min(interval), upper = max(interval), maximum = FALSE, tol = .Machine$double.eps^0.25) ",
		"order.dendrogram" : "order.dendrogram(x) ",
		"p.adjust" : "p.adjust(p, method = p.adjust.methods, n = length(p)) ",
		"pacf" : "pacf(x, lag.max, plot, na.action, ...) ",
		"pairwise.prop.test" : "pairwise.prop.test(x, n, p.adjust.method = p.adjust.methods, ...) ",
		"pairwise.t.test" : "pairwise.t.test(x, g, p.adjust.method = p.adjust.methods, pool.sd = !paired, paired = FALSE, alternative = c(\"two.sided\", \"less\", \"greater\"), ...) ",
		"pairwise.table" : "pairwise.table(compare.levels, level.names, p.adjust.method) ",
		"pairwise.wilcox.test" : "pairwise.wilcox.test(x, g, p.adjust.method = p.adjust.methods, paired = FALSE, ...) ",
		"pbeta" : "pbeta(q, shape1, shape2, ncp = 0, lower.tail = TRUE, log.p = FALSE) ",
		"pbinom" : "pbinom(q, size, prob, lower.tail = TRUE, log.p = FALSE) ",
		"pbirthday" : "pbirthday(n, classes = 365, coincident = 2) ",
		"pcauchy" : "pcauchy(q, location = 0, scale = 1, lower.tail = TRUE, log.p = FALSE) ",
		"pchisq" : "pchisq(q, df, ncp = 0, lower.tail = TRUE, log.p = FALSE) ",
		"pexp" : "pexp(q, rate = 1, lower.tail = TRUE, log.p = FALSE) ",
		"pf" : "pf(q, df1, df2, ncp, lower.tail = TRUE, log.p = FALSE) ",
		"pgamma" : "pgamma(q, shape, rate = 1, scale = 1/rate, lower.tail = TRUE, log.p = FALSE) ",
		"pgeom" : "pgeom(q, prob, lower.tail = TRUE, log.p = FALSE) ",
		"phyper" : "phyper(q, m, n, k, lower.tail = TRUE, log.p = FALSE) ",
		"plclust" : "plclust(tree, hang = 0.1, unit = FALSE, level = FALSE, hmin = 0, square = TRUE, labels = NULL, plot. = TRUE, axes = TRUE, frame.plot = FALSE, ann = TRUE, main = \"\", sub = NULL, xlab = NULL, ylab = \"Height\") ",
		"plnorm" : "plnorm(q, meanlog = 0, sdlog = 1, lower.tail = TRUE, log.p = FALSE) ",
		"plogis" : "plogis(q, location = 0, scale = 1, lower.tail = TRUE, log.p = FALSE) ",
		"plot.ecdf" : "plot.ecdf(x, ..., ylab = \"Fn(x)\", verticals = FALSE, col.01line = \"gray70\", pch = 19) ",
		"plot.spec.coherency" : "plot.spec.coherency(x, ci = 0.95, xlab = \"frequency\", ylab = \"squared coherency\", ylim = c(0, 1), type = \"l\", main = NULL, ci.col = \"blue\", ci.lty = 3, ...) ",
		"plot.spec.phase" : "plot.spec.phase(x, ci = 0.95, xlab = \"frequency\", ylab = \"phase\", ylim = c(-pi, pi), type = \"l\", main = NULL, ci.col = \"blue\", ci.lty = 3, ...) ",
		"plot.stepfun" : "plot.stepfun(x, xval, xlim, ylim = range(c(y, Fn.kn)), xlab = \"x\", ylab = \"f(x)\", main = NULL, add = FALSE, verticals = TRUE, do.points = (n < 1000), pch = par(\"pch\"), col = par(\"col\"), col.points = col, cex.points = par(\"cex\"), col.hor = col, col.vert = col, lty = par(\"lty\"), lwd = par(\"lwd\"), ...) ",
		"plot.ts" : "plot.ts(x, y = NULL, plot.type = c(\"multiple\", \"single\"), xy.labels, xy.lines, panel = lines, nc, yax.flip = FALSE, mar.multi = c(0,     5.1, 0, if (yax.flip) 5.1 else 2.1), oma.multi = c(6,     0, 5, 0), axes = TRUE, ...) ",
		"pnbinom" : "pnbinom(q, size, prob, mu, lower.tail = TRUE, log.p = FALSE) ",
		"pnorm" : "pnorm(q, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE) ",
		"poisson" : "poisson(link = \"log\") ",
		"poisson.test" : "poisson.test(x, T = 1, r = 1, alternative = c(\"two.sided\", \"less\", \"greater\"), conf.level = 0.95) ",
		"poly" : "poly(x, ..., degree = 1, coefs = NULL, raw = FALSE, simple = FALSE) ",
		"polym" : "polym(..., degree = 1, coefs = NULL, raw = FALSE) ",
		"power" : "power(lambda = 1) ",
		"power.anova.test" : "power.anova.test(groups = NULL, n = NULL, between.var = NULL, within.var = NULL, sig.level = 0.05, power = NULL) ",
		"power.prop.test" : "power.prop.test(n = NULL, p1 = NULL, p2 = NULL, sig.level = 0.05, power = NULL, alternative = c(\"two.sided\", \"one.sided\"), strict = FALSE, tol = .Machine$double.eps^0.25) ",
		"power.t.test" : "power.t.test(n = NULL, delta = NULL, sd = 1, sig.level = 0.05, power = NULL, type = c(\"two.sample\", \"one.sample\", \"paired\"), alternative = c(\"two.sided\",     \"one.sided\"), strict = FALSE, tol = .Machine$double.eps^0.25) ",
		"PP.test" : "PP.test(x, lshort = TRUE) ",
		"ppoints" : "ppoints(n, a = if (n <= 10) 3/8 else 1/2) ",
		"ppois" : "ppois(q, lambda, lower.tail = TRUE, log.p = FALSE) ",
		"ppr" : "ppr(x, ...) ",
		"prcomp" : "prcomp(x, ...) ",
		"predict" : "predict(object, ...) ",
		"predict.glm" : "predict.glm(object, newdata = NULL, type = c(\"link\", \"response\", \"terms\"), se.fit = FALSE, dispersion = NULL, terms = NULL, na.action = na.pass, ...) ",
		"predict.lm" : "predict.lm(object, newdata, se.fit = FALSE, scale = NULL, df = Inf, interval = c(\"none\", \"confidence\", \"prediction\"), level = 0.95, type = c(\"response\", \"terms\"), terms = NULL, na.action = na.pass, pred.var = res.var/weights, weights = 1, ...) ",
		"preplot" : "preplot(object, ...) ",
		"princomp" : "princomp(x, ...) ",
		"printCoefmat" : "printCoefmat(x, digits = max(3L, getOption(\"digits\") - 2L), signif.stars = getOption(\"show.signif.stars\"), signif.legend = signif.stars, dig.tst = max(1L, min(5L, digits -     1L)), cs.ind = 1:k, tst.ind = k + 1, zap.ind = integer(), P.values = NULL, has.Pvalue = nc >= 4 && substr(colnames(x)[nc],     1, 3) == \"Pr(\", eps.Pvalue = .Machine$double.eps, na.print = \"NA\", ...) ",
		"profile" : "profile(fitted, ...) ",
		"proj" : "proj(object, ...) ",
		"promax" : "promax(x, m = 4) ",
		"prop.test" : "prop.test(x, n, p = NULL, alternative = c(\"two.sided\", \"less\", \"greater\"), conf.level = 0.95, correct = TRUE) ",
		"prop.trend.test" : "prop.trend.test(x, n, score = seq_along(x)) ",
		"psignrank" : "psignrank(q, n, lower.tail = TRUE, log.p = FALSE) ",
		"pt" : "pt(q, df, ncp, lower.tail = TRUE, log.p = FALSE) ",
		"ptukey" : "ptukey(q, nmeans, df, nranges = 1, lower.tail = TRUE, log.p = FALSE) ",
		"punif" : "punif(q, min = 0, max = 1, lower.tail = TRUE, log.p = FALSE) ",
		"pweibull" : "pweibull(q, shape, scale = 1, lower.tail = TRUE, log.p = FALSE) ",
		"pwilcox" : "pwilcox(q, m, n, lower.tail = TRUE, log.p = FALSE) ",
		"qbeta" : "qbeta(p, shape1, shape2, ncp = 0, lower.tail = TRUE, log.p = FALSE) ",
		"qbinom" : "qbinom(p, size, prob, lower.tail = TRUE, log.p = FALSE) ",
		"qbirthday" : "qbirthday(prob = 0.5, classes = 365, coincident = 2) ",
		"qcauchy" : "qcauchy(p, location = 0, scale = 1, lower.tail = TRUE, log.p = FALSE) ",
		"qchisq" : "qchisq(p, df, ncp = 0, lower.tail = TRUE, log.p = FALSE) ",
		"qexp" : "qexp(p, rate = 1, lower.tail = TRUE, log.p = FALSE) ",
		"qf" : "qf(p, df1, df2, ncp, lower.tail = TRUE, log.p = FALSE) ",
		"qgamma" : "qgamma(p, shape, rate = 1, scale = 1/rate, lower.tail = TRUE, log.p = FALSE) ",
		"qgeom" : "qgeom(p, prob, lower.tail = TRUE, log.p = FALSE) ",
		"qhyper" : "qhyper(p, m, n, k, lower.tail = TRUE, log.p = FALSE) ",
		"qlnorm" : "qlnorm(p, meanlog = 0, sdlog = 1, lower.tail = TRUE, log.p = FALSE) ",
		"qlogis" : "qlogis(p, location = 0, scale = 1, lower.tail = TRUE, log.p = FALSE) ",
		"qnbinom" : "qnbinom(p, size, prob, mu, lower.tail = TRUE, log.p = FALSE) ",
		"qnorm" : "qnorm(p, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE) ",
		"qpois" : "qpois(p, lambda, lower.tail = TRUE, log.p = FALSE) ",
		"qqline" : "qqline(y, datax = FALSE, distribution = qnorm, probs = c(0.25, 0.75), qtype = 7, ...) ",
		"qqnorm" : "qqnorm(y, ...) ",
		"qqplot" : "qqplot(x, y, plot.it = TRUE, xlab = deparse(substitute(x)), ylab = deparse(substitute(y)), ...) ",
		"qsignrank" : "qsignrank(p, n, lower.tail = TRUE, log.p = FALSE) ",
		"qt" : "qt(p, df, ncp, lower.tail = TRUE, log.p = FALSE) ",
		"qtukey" : "qtukey(p, nmeans, df, nranges = 1, lower.tail = TRUE, log.p = FALSE) ",
		"quade.test" : "quade.test(y, ...) ",
		"quantile" : "quantile(x, ...) ",
		"quasi" : "quasi(link = \"identity\", variance = \"constant\") ",
		"quasibinomial" : "quasibinomial(link = \"logit\") ",
		"quasipoisson" : "quasipoisson(link = \"log\") ",
		"qunif" : "qunif(p, min = 0, max = 1, lower.tail = TRUE, log.p = FALSE) ",
		"qweibull" : "qweibull(p, shape, scale = 1, lower.tail = TRUE, log.p = FALSE) ",
		"qwilcox" : "qwilcox(p, m, n, lower.tail = TRUE, log.p = FALSE) ",
		"r2dtable" : "r2dtable(n, r, c) ",
		"rbeta" : "rbeta(n, shape1, shape2, ncp = 0) ",
		"rbinom" : "rbinom(n, size, prob) ",
		"rcauchy" : "rcauchy(n, location = 0, scale = 1) ",
		"rchisq" : "rchisq(n, df, ncp = 0) ",
		"read.ftable" : "read.ftable(file, sep = \"\", quote = \"\\\"\", row.var.names, col.vars, skip = 0) ",
		"rect.hclust" : "rect.hclust(tree, k = NULL, which = NULL, x = NULL, h = NULL, border = 2, cluster = NULL) ",
		"reformulate" : "reformulate(termlabels, response = NULL, intercept = TRUE) ",
		"relevel" : "relevel(x, ref, ...) ",
		"reorder" : "reorder(x, ...) ",
		"replications" : "replications(formula, data = NULL, na.action) ",
		"reshape" : "reshape(data, varying = NULL, v.names = NULL, timevar = \"time\", idvar = \"id\", ids = 1L:NROW(data), times = seq_along(varying[[1L]]), drop = NULL, direction, new.row.names = NULL, sep = \".\", split = if (sep == \"\") {    list(regexp = \"[A-Za-z][0-9]\", include = TRUE)} else {    list(regexp = sep, include = FALSE, fixed = TRUE)}) ",
		"resid" : "resid(object, ...) ",
		"residuals" : "residuals(object, ...) ",
		"residuals.glm" : "residuals.glm(object, type = c(\"deviance\", \"pearson\", \"working\", \"response\", \"partial\"), ...) ",
		"residuals.lm" : "residuals.lm(object, type = c(\"working\", \"response\", \"deviance\", \"pearson\", \"partial\"), ...) ",
		"rexp" : "rexp(n, rate = 1) ",
		"rf" : "rf(n, df1, df2, ncp) ",
		"rgamma" : "rgamma(n, shape, rate = 1, scale = 1/rate) ",
		"rgeom" : "rgeom(n, prob) ",
		"rhyper" : "rhyper(nn, m, n, k) ",
		"rlnorm" : "rlnorm(n, meanlog = 0, sdlog = 1) ",
		"rlogis" : "rlogis(n, location = 0, scale = 1) ",
		"rmultinom" : "rmultinom(n, size, prob) ",
		"rnbinom" : "rnbinom(n, size, prob, mu) ",
		"rnorm" : "rnorm(n, mean = 0, sd = 1) ",
		"rpois" : "rpois(n, lambda) ",
		"rsignrank" : "rsignrank(nn, n) ",
		"rstandard" : "rstandard(model, ...) ",
		"rstudent" : "rstudent(model, ...) ",
		"rt" : "rt(n, df, ncp) ",
		"runif" : "runif(n, min = 0, max = 1) ",
		"runmed" : "runmed(x, k, endrule = c(\"median\", \"keep\", \"constant\"), algorithm = NULL, print.level = 0) ",
		"rweibull" : "rweibull(n, shape, scale = 1) ",
		"rwilcox" : "rwilcox(nn, m, n) ",
		"rWishart" : "rWishart(n, df, Sigma) ",
		"scatter.smooth" : "scatter.smooth(x, y = NULL, span = 2/3, degree = 1, family = c(\"symmetric\", \"gaussian\"), xlab = NULL, ylab = NULL, ylim = range(y, pred$y, na.rm = TRUE), evaluation = 50, ..., lpars = list()) ",
		"screeplot" : "screeplot(x, ...) ",
		"sd" : "sd(x, na.rm = FALSE) ",
		"se.contrast" : "se.contrast(object, ...) ",
		"selfStart" : "selfStart(model, initial, parameters, template) ",
		"setNames" : "setNames(object = nm, nm) ",
		"shapiro.test" : "shapiro.test(x) ",
		"sigma" : "sigma(object, ...) ",
		"simulate" : "simulate(object, nsim = 1, seed = NULL, ...) ",
		"smooth" : "smooth(x, kind = c(\"3RS3R\", \"3RSS\", \"3RSR\", \"3R\", \"3\", \"S\"), twiceit = FALSE, endrule = c(\"Tukey\", \"copy\"), do.ends = FALSE) ",
		"smooth.spline" : "smooth.spline(x, y = NULL, w = NULL, df, spar = NULL, cv = FALSE, all.knots = FALSE, nknots = .nknots.smspl, keep.data = TRUE, df.offset = 0, penalty = 1, control.spar = list(), tol = 1e-06 *     IQR(x)) ",
		"smoothEnds" : "smoothEnds(y, k = 3) ",
		"sortedXyData" : "sortedXyData(x, y, data) ",
		"spec.ar" : "spec.ar(x, n.freq, order = NULL, plot = TRUE, na.action = na.fail, method = \"yule-walker\", ...) ",
		"spec.pgram" : "spec.pgram(x, spans = NULL, kernel = NULL, taper = 0.1, pad = 0, fast = TRUE, demean = FALSE, detrend = TRUE, plot = TRUE, na.action = na.fail, ...) ",
		"spec.taper" : "spec.taper(x, p = 0.1) ",
		"spectrum" : "spectrum(x, ..., method = c(\"pgram\", \"ar\")) ",
		"spline" : "spline(x, y = NULL, n = 3 * length(x), method = \"fmm\", xmin = min(x), xmax = max(x), xout, ties = mean) ",
		"splinefun" : "splinefun(x, y = NULL, method = c(\"fmm\", \"periodic\", \"natural\", \"monoH.FC\", \"hyman\"), ties = mean) ",
		"splinefunH" : "splinefunH(x, y, m) ",
		"SSasymp" : "SSasymp(input, Asym, R0, lrc) ",
		"SSasympOff" : "SSasympOff(input, Asym, lrc, c0) ",
		"SSasympOrig" : "SSasympOrig(input, Asym, lrc) ",
		"SSbiexp" : "SSbiexp(input, A1, lrc1, A2, lrc2) ",
		"SSD" : "SSD(object, ...) ",
		"SSfol" : "SSfol(Dose, input, lKe, lKa, lCl) ",
		"SSfpl" : "SSfpl(input, A, B, xmid, scal) ",
		"SSgompertz" : "SSgompertz(x, Asym, b2, b3) ",
		"SSlogis" : "SSlogis(input, Asym, xmid, scal) ",
		"SSmicmen" : "SSmicmen(input, Vm, K) ",
		"SSweibull" : "SSweibull(x, Asym, Drop, lrc, pwr) ",
		"start" : "start(x, ...) ",
		"stat.anova" : "stat.anova(table, test = c(\"Rao\", \"LRT\", \"Chisq\", \"F\", \"Cp\"), scale, df.scale, n) ",
		"step" : "step(object, scope, scale = 0, direction = c(\"both\", \"backward\", \"forward\"), trace = 1, keep = NULL, steps = 1000, k = 2, ...) ",
		"stepfun" : "stepfun(x, y, f = as.numeric(right), ties = \"ordered\", right = FALSE) ",
		"stl" : "stl(x, s.window, s.degree = 0, t.window = NULL, t.degree = 1, l.window = nextodd(period), l.degree = t.degree, s.jump = ceiling(s.window/10), t.jump = ceiling(t.window/10), l.jump = ceiling(l.window/10), robust = FALSE, inner = if (robust) 1 else 2, outer = if (robust) 15 else 0, na.action = na.fail) ",
		"StructTS" : "StructTS(x, type = c(\"level\", \"trend\", \"BSM\"), init = NULL, fixed = NULL, optim.control = NULL) ",
		"summary.aov" : "summary.aov(object, intercept = FALSE, split, expand.split = TRUE, keep.zero.df = TRUE, ...) ",
		"summary.glm" : "summary.glm(object, dispersion = NULL, correlation = FALSE, symbolic.cor = FALSE, ...) ",
		"summary.lm" : "summary.lm(object, correlation = FALSE, symbolic.cor = FALSE, ...) ",
		"summary.manova" : "summary.manova(object, test = c(\"Pillai\", \"Wilks\", \"Hotelling-Lawley\", \"Roy\"), intercept = FALSE, tol = 1e-07, ...) ",
		"summary.stepfun" : "summary.stepfun(object, ...) ",
		"supsmu" : "supsmu(x, y, wt = rep(1, n), span = \"cv\", periodic = FALSE, bass = 0) ",
		"symnum" : "symnum(x, cutpoints = c(0.3, 0.6, 0.8, 0.9, 0.95), symbols = if (numeric.x) c(\" \", \".\", \",\", \"+\", \"*\", \"B\") else c(\".\", \"|\"), legend = length(symbols) >= 3, na = \"?\", eps = 1e-05, numeric.x = is.numeric(x), corr = missing(cutpoints) && numeric.x, show.max = if (corr) \"1\", show.min = NULL, abbr.colnames = has.colnames, lower.triangular = corr && is.numeric(x) && is.matrix(x), diag.lower.tri = corr && !is.null(show.max)) ",
		"t.test" : "t.test(x, ...) ",
		"termplot" : "termplot(model, data = NULL, envir = environment(formula(model)), partial.resid = FALSE, rug = FALSE, terms = NULL, se = FALSE, xlabs = NULL, ylabs = NULL, main = NULL, col.term = 2, lwd.term = 1.5, col.se = \"orange\", lty.se = 2, lwd.se = 1, col.res = \"gray\", cex = 1, pch = par(\"pch\"), col.smth = \"darkred\", lty.smth = 2, span.smth = 2/3, ask = dev.interactive() && nb.fig < n.tms, use.factor.levels = TRUE, smooth = NULL, ylim = \"common\", plot = TRUE, transform.x = FALSE, ...) ",
		"terms" : "terms(x, ...) ",
		"terms.formula" : "terms.formula(x, specials = NULL, abb = NULL, data = NULL, neg.out = TRUE, keep.order = FALSE, simplify = FALSE, ..., allowDotAsName = FALSE) ",
		"time" : "time(x, ...) ",
		"toeplitz" : "toeplitz(x) ",
		"ts" : "ts(data = NA, start = 1, end = numeric(), frequency = 1, deltat = 1, ts.eps = getOption(\"ts.eps\"), class = if (nseries >     1) c(\"mts\", \"ts\", \"matrix\") else \"ts\", names = if (!is.null(dimnames(data))) colnames(data) else paste(\"Series\",     seq(nseries))) ",
		"ts.intersect" : "ts.intersect(..., dframe = FALSE) ",
		"ts.plot" : "ts.plot(..., gpars = list()) ",
		"ts.union" : "ts.union(..., dframe = FALSE) ",
		"tsdiag" : "tsdiag(object, gof.lag, ...) ",
		"tsp" : "tsp(x) ",
		"tsSmooth" : "tsSmooth(object, ...) ",
		"TukeyHSD" : "TukeyHSD(x, which, ordered = FALSE, conf.level = 0.95, ...) ",
		"uniroot" : "uniroot(f, interval, ..., lower = min(interval), upper = max(interval), f.lower = f(lower, ...), f.upper = f(upper, ...), extendInt = c(\"no\",     \"yes\", \"downX\", \"upX\"), check.conv = FALSE, tol = .Machine$double.eps^0.25, maxiter = 1000, trace = 0) ",
		"update" : "update(object, ...) ",
		"update.default" : "update.default(object, formula., ..., evaluate = TRUE) ",
		"update.formula" : "update.formula(old, new, ...) ",
		"var" : "var(x, y = NULL, na.rm = FALSE, use) ",
		"var.test" : "var.test(x, ...) ",
		"variable.names" : "variable.names(object, ...) ",
		"varimax" : "varimax(x, normalize = TRUE, eps = 1e-05) ",
		"vcov" : "vcov(object, ...) ",
		"weighted.mean" : "weighted.mean(x, w, ...) ",
		"weighted.residuals" : "weighted.residuals(obj, drop0 = TRUE) ",
		"weights" : "weights(object, ...) ",
		"wilcox.test" : "wilcox.test(x, ...) ",
		"window" : "window(x, ...) ",
		"write.ftable" : "write.ftable(x, file = \"\", quote = TRUE, append = FALSE, digits = getOption(\"digits\"), ...) ",
		"xtabs" : "xtabs(formula = ~., data = parent.frame(), subset, sparse = FALSE, na.action, exclude = c(NA, NaN), drop.unused.levels = FALSE) "
	}
}